# 日历(含农历)

## 目标
弄懂，搞懂日历(含农历)！

## 思路
日历分为两种，分别是[阳历](https://baike.sogou.com/v265289.htm?fromTitle=%E9%98%B3%E5%8E%86)和[阴历(农历)](https://baike.baidu.com/item/%E5%86%9C%E5%8E%86/67925)；

阳历日期有规律可循，容易理解并计算。

阴历(农历)日期并无规律可循，主要是从天文台夜观天象得来的，而现有[阴历(农历)数据](https://www.hko.gov.hk/tc/gts/time/conversion1_text.htm#)只有1949年-2100年，共200年的数据。

阳历与阴历(农历)每天的日期信息都知道后，利用**日期基准的方式**计算出**当天的阳历日期与阴历(农历)日期**

<br>

### 阳历
阳历日期每年每月的日期都为固定天数，除了要考虑[闰年](https://baike.baidu.com/item/%E9%97%B0%E5%B9%B4/27098)下的2月份天数，其余月份天数均为固定天数

```
// 1 - 12月每月的天数
const month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
```

[闰年](https://baike.baidu.com/item/%E9%97%B0%E5%B9%B4/27098)又分为普通闰年和世纪闰年

```
// 计算2月份 是28天, 还是29天

const year = 2020

month[1] = (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0) ? 29 : 28
```

### 阴历(农历)
根据天文台数据，就已经知道每年每月的日期信息了，但是并不方便使用，所以一些前辈把这些数据源转成了16进制编码来方便使用
```
// 1949年 - 2100年 农历年份  >> 注:使用时是 10进制 并非 16进制
// 1996年 原本是0x055c0; 百度、微软、App日历都为0x05ac0

const LUNAR_ARR = [
  0x0b557, //1949
  0x06ca0, 0x0b550, 0x15355, 0x04da0, 0x0a5b0, 0x14573, 0x052b0, 0x0a9a8, 0x0e950, 0x06aa0, //1950-1959
  0x0aea6, 0x0ab50, 0x04b60, 0x0aae4, 0x0a570, 0x05260, 0x0f263, 0x0d950, 0x05b57, 0x056a0, //1960-1969
  0x096d0, 0x04dd5, 0x04ad0, 0x0a4d0, 0x0d4d4, 0x0d250, 0x0d558, 0x0b540, 0x0b6a0, 0x195a6, //1970-1979
  0x095b0, 0x049b0, 0x0a974, 0x0a4b0, 0x0b27a, 0x06a50, 0x06d40, 0x0af46, 0x0ab60, 0x09570, //1980-1989
  0x04af5, 0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06b58, 0x05ac0, 0x0ab60, 0x096d5, 0x092e0, //1990-1999
  0x0c960, 0x0d954, 0x0d4a0, 0x0da50, 0x07552, 0x056a0, 0x0abb7, 0x025d0, 0x092d0, 0x0cab5, //2000-2009
  0x0a950, 0x0b4a0, 0x0baa4, 0x0ad50, 0x055d9, 0x04ba0, 0x0a5b0, 0x15176, 0x052b0, 0x0a930, //2010-2019
  0x07954, 0x06aa0, 0x0ad50, 0x05b52, 0x04b60, 0x0a6e6, 0x0a4e0, 0x0d260, 0x0ea65, 0x0d530, //2020-2029
  0x05aa0, 0x076a3, 0x096d0, 0x04afb, 0x04ad0, 0x0a4d0, 0x1d0b6, 0x0d250, 0x0d520, 0x0dd45, //2030-2039
  0x0b5a0, 0x056d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0, 0x0aa50, 0x1b255, 0x06d20, 0x0ada0, //2040-2049
  0x14b63, 0x09370, 0x049f8, 0x04970, 0x064b0, 0x168a6, 0x0ea50, 0x06b20, 0x1a6c4, 0x0aae0, //2050-2059
  0x0a2e0, 0x0d2e3, 0x0c960, 0x0d557, 0x0d4a0, 0x0da50, 0x05d55, 0x056a0, 0x0a6d0, 0x055d4, //2060-2069
  0x052d0, 0x0a9b8, 0x0a950, 0x0b4a0, 0x0b6a6, 0x0ad50, 0x055a0, 0x0aba4, 0x0a5b0, 0x052b0, //2070-2079
  0x0b273, 0x06930, 0x07337, 0x06aa0, 0x0ad50, 0x14b55, 0x04b60, 0x0a570, 0x054e4, 0x0d160, //2080-2089
  0x0e968, 0x0d520, 0x0daa0, 0x16aa6, 0x056d0, 0x04ae0, 0x0a9d4, 0x0a2d0, 0x0d150, 0x0f252, //2090-2099
  0x0d520 //2100
]
```

### 日期基准
现在就要根据日期基准计算出当天的阳历日期和阴历(农历)日期

1、基准公式

> (输入的阳历日期 − 阳历基准 + 1) = (输出的阴历日期 − 阴历基准 + 1) = 相差天数<br><br>
> 1、先计算`输入的阳历日期`与`阳历基准`之间`相差天数`，计算出的相差天数是固定的<br>
> 2、之后在根据 相差天数反推出阴历日期

2、确认基准日期

基准可以是日历上的任意一天，但是**阳历基准和阴历基准必须是同一天**。 要注意的是设置基准后，基准以前的日期将计算错误，只能计算基准以后的。

**基准年份要与阴历年份数组第一个值相对应**，要不然也会出现计算误差。
```
const SOLAR_YEAR = 1949  // 阳历基准年份

const LUNAR_ARR = [
  0x0b557, //1949 - 阴历基准年份
  .......,
  0x0d520 //2100
]
```

3、计算相差天数

相差天数 = 输入的阳历日期 - 阳历基准 + 1

[Date.UTC](https://www.w3school.com.cn/jsref/jsref_utc.asp) 方法
```
// sy, sm, sd = 年, 月, 日

const diff = (Date.UTC(sy, sm, sd) - Date.UTC(1949, 0, 29)) / (24 * 60 * 60 * 1000) + 1;
```

4、计算阴历年份

> 剩余相差天数 = 相差天数 **依次减去** 阴历数组中每一年的天数<br>
> 剩余相差天数 <= 0时 即`确认当前阴历年份`

5、计算阴历月份

> 当前阴历年份的相差天数 = 最后一次减去的阴历年份天数 + 剩余相差天数<br><br>
> 剩余相差天数 = 当前阴历年份的相差天数 **依次减去** 当前阴历年份中的每月的天数<br>
> 剩余相差天数 <= 0时 即`确认当前阴历月份`

6、计算阴历日份

> `当前阴历日份` = 最后一次减去的阴历月份天数 + 剩余相差天数


### 其他准备工作

<span id="year">1、使用16进制编码的阴历年份</span>
```
const LUNAR_ARR = [
  0x0b557, //1949 
  0x06ca0, 0x0b550, 0x15355,
  ......
]
```
将 0x0b557 除 0x 外的 0b557(16进制) 转为 二进制，会得到以下数据：

0000 1011 0101 0101 0111

分别表示：

xxxx | xxxx | xxxx | xxxx | xxxx
---  | ---  | ---  | ---  | ---
20-17| 16-12| 12-9 | 8-5  |	4-1

1-4位： 表示是否为闰年，是 则为闰年的月份； 否 为 0；

5-16位： 除闰年外的正常月份，1为 30天大月；0为 29天小月；**(1月-12月的对应顺序为16位-5位)**

17-20位：表示闰月为 大月还是小月，有闰月时才有意义；**农历大月为30天 小月为29天**

【示例1】
```
>> 无闰月版

2019年的 16进制为0x0a930 二进制为 1010100100110000

1010 1001 0011 0000; 可以看到 17-20位是没有的，因为2019年没有闰月

2019年全年月份1-12月
30,29,30,29,  30,29,29,30,  29,29,30,30
```
```
>> 有闰月-小月版

2020年的 16进制为0x07954 二进制为111100101010100 //这里的二进制只有15位, 手动添0，添置到16位

0111 1001 0101 0100; 1-4位 0100 转成 十进制为 4 所以是闰4月; 17-20位不存在则为小月29天

2020年全年月份 1-12月 + 闰4月 = 13月
1-12月: 29,30,30,30,        30,29,29,30  29,30,29,30
闰4月:                 29,
1-13月: 29,30,30,30,   29,  30,29,29,30  29,30,29,30
```

```
>> 有闰月-大月版

2036年的 16进制为0x1d0b6 二进制为11101000010110110 //这里的二进制只有17位，手动添0，添置到20位

0001 1101 0000 1011 0110; 1-4位 0110 转成 十进制为 6 所以是闰6月; 17-20位存在则为大月30天

2036年全年月份 1-12月 + 闰6月 = 13月
1-12月: 30,30,29,30, 29,29,       29,29  30,29,30,30
闰6月:                       30,
1-13月: 30,30,29,30, 29,29,  30,  29,29  30,29,30,30
```

2、计算阴历年份天数

根据[【1、使用16进制编码的阴历年份】](#year)知道每月天数后，**依次相加** 计算出每年的天数，不要忘了闰年天数也要加上！

3、计算阴历月份天数

根据[【1、使用16进制编码的阴历年份】](#year)知道每月天数后，获取知道月份的天数即可。

4、阴历闰月注意

阴历为闰月的情况下，当前阴历年就会有 13个月，其中一个月为闰月，所以取月份天数时，要考虑闰月情况


5、数组进制

我们将天文台数据，转为16进制存放在数组中，但当我们使用时，js会自动将16进制转为10进制
```
const LUNAR_ARR = [
  0x0b557, //1949 
  0x06ca0, 0x0b550, 0x15355,
  ......
]

console.log(LUNAR_ARR[0]) // 46423
```

6、进制转换

> 2进制转10进制：[parseInt](https://www.w3school.com.cn/jsref/jsref_parseInt.asp)方法<br>
> 10进制转2进制：[toString](https://www.runoob.com/jsref/jsref-tostring-number.html)方法




### 示例

<span id='diff'>1、计算出阴历年份</span>

```
const diff = 26248   // 2020年12月09日 至 1949年01月29日的 相差天数
const BASIS = 1949   // 基准年 1949 年

// 这里是直接使用的年份天数，记得要手动将10进制转换为2进制，并计算出每年的总天数
const LUNAR_ARR = [
    384, //1949
    354, 355, 384, 354, //1950-1953
    ......, 
]

let ly = 0  // 阴历年

// 相差天数 依次减去 阴历数组中每一年的天数
for (let i = 0; LUNAR_ARR.length < i; i++) {
  diff -= LUNAR_ARR[i]

  if (diff <= 0) {
    ly = BASIS + i 
    diff += LUNAR_ARR[i] // 剩余相差天数 320天
    break;
  }
}
console.log(ly) // 2020年
```

2、计算阴历月和阴历日

```
// 2020年 16进制 0x07954 转 2进制 111100101010100 
// 111100101010100 不足20位 在前面添置 0 补充位数至20位

// 1-4位  : 0100 = 4 = 闰 4 月
// 5-16位 : 0111 1001 0101 = 29,30,30,30,  30,29,29,30,  29,30,29,30
// 17-20位: 0000 = 0 = 小月

let month = [29,30,30,30,       30,29,29,30, 29,30,29,30] // 正常月份
    month = [29,30,30,30,  29,  30,29,29,30, 29,30,29,30] // 加上 闰4月的 天数
```

这里`剩余相差天数diff = 320`由[【1、计算出阴历年份】](#diff)计算得出

```
let lm = 0,  // 农历月
    ld = 0;  // 农历日

let diff = 320 // 剩余相差天数

// 当前阴历年份的相差天数 依次减去 当前阴历年份中的每月的天数
for (let i = 0; month.length >= i; i++){
  diff -= month[i]

  if (diff <= 0) {

    // 剩余相差天数 <= 0时 即确认当前阴历月份；减至小于0时 i = 10

    if (month.length === 13) { // 长度13 代表有闰月
      let m = 4 // 由 1-4位计算出是 闰4月

      // 考虑当前月份是否时闰月，(m < i = 4 < 10) ? (lm = 10) : ''
      if (m < i) lm = i
      else if (m === i) lm = `闰${m}`
      else lm = i + 1 

    } else {
      lm = i + 1
    }

    // 最后一次减去的阴历月份天数 + 剩余相差天数
    // i = 10
    // diff = -5，month[i] = 30

    ld = diff += month[i] // 25
    break
  }
}
console.log(ly, lm, ld) // 2020年10月25日
```

由此对应`阳历2020年12月09日` = `阴历2020年10月25日`

到这里日历的计算方式，基本上都已经完成了，不过日历展示上面，往往还有其他的信息，比如：节日、节气、天干地支等其他辅助信息。下面就列举一二

### 其他信息

1、天干地支

天干=（公历年份）/10，所得余数

地支=（公历年份）/12，所得余数

生肖与地支公式一样

天干 |甲 | 乙 | 丙 | 丁  | 戊  | 己  | 庚 | 辛  | 壬  | 癸
--- | ---| ---| ---| --- | --- | --- | ---| ---| --- | ---
余数 | 4  | 5  | 6  | 7   | 8   | 9   | 0  | 1  | 2   | 3


地支 |子 |丑 | 寅 | 卯 | 辰 | 巳 | 午 | 未 | 申 | 酉 | 戌 | 亥 
--- | ---| ---| ---| ---| ---| ---| ---| ---| --- | ---| ---| ---
余数   | 4  | 5  | 6  | 7  |  8 | 9  | 10 | 11 | 12  | 1  | 2  | 3 


生肖 |鼠 |牛 | 虎 | 兔 | 龙 | 蛇 | 马 | 羊 | 猴 | 鸡 | 狗 | 猪 
--- | ---| ---| ---| ---| ---| ---| ---| ---| --- | ---| ---| ---
余数   | 4  | 5  | 6  | 7  |  8 | 9  | 10 | 11 | 12  | 1  | 2  | 3 

2、节日
```
>> 阴历节日

{
  '1223': '北方小年',
  '1224': '南方小年',
  '1230': '除夕',
  '0101': '春节',
  '0115': '元宵',
  '0202': '龙抬头',
  '0505': '端午节',
  '0707': '七夕',
  '0815': '中秋节',
  '0909': '重阳节',
  '1013': '生日',
  '1208': '腊八'
}
```

```
>> 阳历节日

{
  '0101': '元旦',
  '0214': '情人节',
  '0308': '妇女节',
  '0312': '植树节',
  '0315': '消费者日',
  '0401': '愚人节',
  '0501': '劳动节',
  '0504': '青年节',
  '0512': '护士节',
  '0601': '儿童节',
  '0701': '建党日',
  '0801': '建军节',
  '0910': '教师节',
  '0918': '九一八',
  '1001': '国庆节',
  '1013': '生日',
  '1111': '光棍节',
  '1224': '平安夜',
  '1225': '圣诞节'
}
```


3、节气

虽然已经实现节气了、但总感觉哪里不对劲、解惑后再来。

简单来说，也是通过某一年的节气基准，然后计算以后每年的节气信息



## 最后
能明白如何计算日历，感觉还是很开心的。

不过有些疑虑，当各个平台将日期偷偷修改后、大众是无感知的。

## 参考文献
[1] [limengwe-关于日历实现代码里0x04bd8, 0x04ae0, 0x0a570的解释](https://blog.csdn.net/onlyonecoder/article/details/8484118)

[2] [xm2by-日历的公历转农历](https://blog.csdn.net/XuM222222/article/details/82012802)

[3] [xm2by-原生js实现公历转农历](https://blog.csdn.net/XuM222222/article/details/82022345)

[4] [天干地支-百度百科](https://baike.baidu.com/item/%E5%A4%A9%E5%B9%B2%E5%9C%B0%E6%94%AF)

[5] [闰年-百度百科](https://baike.baidu.com/item/%E9%97%B0%E5%B9%B4/27098)